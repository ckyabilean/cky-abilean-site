<!DOCTYPE html>
<html>
<head>
  <title>Animation Test</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      background: #000;
      color: #0f0;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 0;
    }

    .items-container {
      padding: 40px 20px;
    }

    .item {
      font-size: 48px;
      margin-bottom: 120px;
      transition: transform 0.2s ease-out;
      cursor: pointer;
    }

    .sticky-container {
      position: sticky;
      top: 100px;
      height: 200px;
      z-index: 50;
      overflow: visible;
    }
    
    /* Controls panel */
    .controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 20, 0, 0.8);
      padding: 15px;
      border: 1px solid #0f0;
      z-index: 100;
    }
    
    .controls button {
      background: #0f0;
      color: #000;
      border: none;
      padding: 8px 15px;
      margin: 5px;
      cursor: pointer;
      font-family: 'Courier New', monospace;
    }
    
    .controls label {
      display: block;
      margin: 10px 0 5px;
    }
    
    /* Scramble effect styling */
    .scramble-char {
      display: inline-block;
    }
    
    @media (max-width: 768px) {
      .item {
        font-size: 32px;
      }
    }
  </style>
</head>
<body>
  <div id="content">
    <div class="items-container">
      <div class="item">ITEM A</div>
      <div class="item">ITEM B</div>
      <div class="item">ITEM C</div>
      <div class="item">ITEM D</div>
      <div class="item">ITEM E</div>
      <div class="item">ITEM F</div>
      <div class="item">ITEM G</div>
    </div>
  </div>
  
  <div class="controls">
    <button id="resetBtn">Reset Animation</button>
    <label>
      Scramble Speed:
      <input type="range" id="scrambleSpeed" min="1" max="10" value="5">
    </label>
    <label>
      Chaos Intensity:
      <input type="range" id="chaosIntensity" min="1" max="20" value="10">
    </label>
  </div>
  
  <script>
    // Text scramble effect class
    class TextScramble {
      constructor(element) {
        this.element = element;
        this.originalText = element.innerText;
        this.chars = '!<>-_\\/[]{}â€”=+*^?#________';
        this.frameRate = 15;
        this.frameRequest = null;
        this.frames = 0;
        this.finalText = this.originalText;
      }
      
      randomChar() {
        return this.chars[Math.floor(Math.random() * this.chars.length)];
      }
      
      update() {
        const speed = parseInt(document.getElementById('scrambleSpeed').value);
        let output = '';
        let complete = true;
        
        // Create scrambled version of text
        for (let i = 0; i < this.finalText.length; i++) {
          // If character should be scrambled
          if (this.frames < 10 * (10 - speed) || Math.random() < this.frames / (100 * (10 - speed))) {
            output += `<span class="scramble-char">${this.randomChar()}</span>`;
            complete = false;
          } else {
            output += `<span class="scramble-char">${this.finalText[i]}</span>`;
          }
        }
        
        this.element.innerHTML = output;
        
        if (!complete) {
          this.frames++;
          this.frameRequest = requestAnimationFrame(() => this.update());
        }
      }
      
      start() {
        this.frames = 0;
        cancelAnimationFrame(this.frameRequest);
        this.update();
      }
      
      reset() {
        cancelAnimationFrame(this.frameRequest);
        this.element.innerText = this.originalText;
      }
    }
  
    // Initialize main animation
    const items = document.querySelectorAll('.item');
    const content = document.getElementById('content');
    const scrambleInstances = [];

    // Create sticky container
    const stickyContainer = document.createElement('div');
    stickyContainer.className = 'sticky-container';
    content.prepend(stickyContainer);

    // Item states
    const itemStates = {};
    
    // Initialize scramble effect for each item
    items.forEach(item => {
      const scrambler = new TextScramble(item);
      scrambleInstances.push(scrambler);
    });

    // Controls
    document.getElementById('resetBtn').addEventListener('click', () => {
      // Clear all sticky items
      stickyContainer.innerHTML = '';
      
      // Reset states
      Object.keys(itemStates).forEach(key => {
        delete itemStates[key];
      });
      
      // Show all original items
      items.forEach(item => {
        item.style.opacity = 1;
      });
    });

    window.addEventListener('scroll', () => {
      const chaosIntensity = parseInt(document.getElementById('chaosIntensity').value);
      
      items.forEach((item, index) => {
        const rect = item.getBoundingClientRect();
        
        // If item reaches threshold
        if (rect.top < 200) {
          if (!itemStates[index]) {
            // Clone the item for the sticky container
            const clone = item.cloneNode(true);
            clone.id = `sticky-${index}`;
            clone.style.position = 'absolute';
            stickyContainer.appendChild(clone);
            
            // Mark this item as at the top
            itemStates[index] = {
              element: clone,
              x: 0,
              y: 0, 
              rotation: 0,
              chaos: 0,
              scrambler: new TextScramble(clone)
            };
            
            // Start text scramble
            itemStates[index].scrambler.start();
            
            // Hide original
            item.style.opacity = 0;
          }
          
          // Increase chaos based on how far we've scrolled past it
          const distancePastThreshold = 200 - rect.top;
          const chaos = Math.min(1, distancePastThreshold / 300);
          
          itemStates[index].chaos = chaos;
          itemStates[index].x += (Math.random() * 3 * chaosIntensity - 1.5 * chaosIntensity) * chaos;
          itemStates[index].y = Math.random() * 2 * chaosIntensity * chaos;
          itemStates[index].rotation += (Math.random() * 2 * chaosIntensity - 1 * chaosIntensity) * chaos;
          
          // Apply transformation
          itemStates[index].element.style.transform = 
            `translate(${itemStates[index].x}px, ${itemStates[index].y}px) rotate(${itemStates[index].rotation}deg)`;
        }
        // If scrolling back up
        else if (itemStates[index]) {
          itemStates[index].x *= 0.8;
          itemStates[index].y *= 0.8;
          itemStates[index].rotation *= 0.8;
          
          // Apply reduced transformation
          itemStates[index].element.style.transform = 
            `translate(${itemStates[index].x}px, ${itemStates[index].y}px) rotate(${itemStates[index].rotation}deg)`;
          
          // If nearly reset, remove from sticky and show original
          if (Math.abs(itemStates[index].x) < 5 && 
              Math.abs(itemStates[index].y) < 5 && 
              Math.abs(itemStates[index].rotation) < 5) {
            stickyContainer.removeChild(itemStates[index].element);
            delete itemStates[index];
            item.style.opacity = 1;
          }
        }
      });
    });
  </script>
</body>
</html>
